Міністерство освіти і науки України
Харківський національний університет радіоелектроніки
 
 
Кафедра програмної інженерії
 
 
Звіт
до практичної роботи №2
з «Аналізу та рефакторингу коду»
 
 
 Виконав:                                                                        Перевірила:
студент групи ПЗПІ-22-9                                   ст. викладач кафедри ПІ
Переверзєв Г. В.                                                               Сокорчук І. П








Харків 2024
________________
Зміст

•Титульний слайд
•Зміст
•Що таке рефакторинг
•Метод рефакторингу: Replace Array with Object
•Hide Delegate (Приховування делегата)
•Encapsulate Collection.
•Інструменти рефакторингу
•Висновки
•Список використаних джерел
1. Що таке рефакторинг
Рефакторинг коду – це процес реструктуризації коду без зміни його вихідної функціональності. Мета рефакторингу – поліпшити внутрішній код шляхом внесення безлічі невеликих корегувань без зміни зовнішньої поведінки коду. Можна розробити програму на власний розсуд, забезпечивши її функціональність, однак необхідно провести рефакторинг вихідного коду, щоб поліпшити його структуру і читабельність. Навіщо, запитаєте ви, проводити рефакторинг програмного коду, якщо він не вносить змін до функціонала програми? Саме про це ми поговоримо сьогодні в моїй доповіді.


Основні цілі проведення рефакторингу: 
* підвищення читабельності коду;
* зменшення складності;
* удосконалення ремонтопридатності вихідного коду;
* поліпшення розширюваності;
* підвищення продуктивності;
* полегшення швидкого виконання програми.   


Перш ніж визначити етапи проєкту, на яких потрібен рефакторинг і оптимізація програмного коду, давайте розглянемо поширені ситуації, коли його варто провести:   
1. Код складно читати і розуміти. Наприклад, якщо програмний продукт розроблявся роками, цілком імовірно, що команда розробників змінилася, тому рефакторинг буде гарною ідеєю, щоб допомогти новим членам команди зрозуміти код і допомогти процесу розробки пройти гладко.   
2. Необхідно масштабуватися. Щоб оптимізувати ресурс під час додавання нового функціонала і виправити проблеми, які можуть виникнути на шляху (через брудний код), варто провести рефакторинг коду. Рефакторинг може усунути дрібні помилки до того, як вони перетворяться на серйозні проблеми.  
3. За наявності дублювання ділянок коду. Коли є дублювання частин коду, які часто використовуються в програмному забезпеченні, рефакторинг значно спрощує зміни в коді.     


Етапи розробки для проведення рефакторингу   
Отже, якщо ви плануєте рефакторити свій код, ось етапи розробки програмного забезпечення, на яких проведення рефакторингу коду підходить найбільше:   
Стадія розробки 
З огляду на тенденцію, яка полягає в тому, що через вимоги бізнесу розробникам здебільшого доводиться прискорювати реалізацію проєкту, який згодом необхідно буде рефакторити, завжди корисно очистити код перед випуском продукту. Так, ти можеш зробити це після запуску продукту; однак через помилки коду, що спричиняють зниження продуктивності, перше враження користувачів може бути зіпсоване. Тому не нехтуй важливістю рефакторингу.   


Застосування нових функцій 
Якщо ви хочете оновити продукт, рефакторинг є обов’язковим, щоб очистити код від проблем до того, як вони почнуть поширюватися. Отже, у довгостроковій перспективі ти заощадиш час і гроші для себе або інших команд розробників.   


Коли з’являються помилки
Безладний код впливає на якість обслуговування клієнтів, і замість того, щоб витрачати гроші на маркетинг, зверни увагу на рефакторинг коду, оскільки які б маркетингові методи ти не застосовував, нікому не потрібен продукт, якщо він несправний. Ба більше, бізнес-процеси можуть опинитися під загрозою через порушення безпеки, які можуть виникнути під час виявлення помилок у внутрішніх системах.    


 А коли не варто застосовувати рефакторинг коду?   
Рефакторинг коду може виявитися більш витратним, ніж переписувати його з нуля. Такі випадки трапляються, коли код абсолютно нечитабельний і застарілий, що його неможливо підтримувати і розширювати. Також якщо продукт має суворі терміни доставки на ринок. Можливо, це здається парадоксальним (з огляду на вищенаведену пораду про рефакторинг коду на етапі розробки), але іноді процес рефакторингу може зайняти набагато більше часу, ніж планувалося. Таким чином, буде розумно відкласти рефакторинг і провести його після закінчення крайнього терміну.


2. Метод рефакторингу: Replace Array with Object


Replace Array with Object – це один із методів рефакторингу, запропонований Мартіном Фаулером, який полягає у перетворенні масиву, що використовується для зберігання пов'язаних даних, на об'єкт із чітко визначеними полями. Цей метод підвищує читабельність, зручність у роботі з кодом і зменшує ризик помилок.


Чому це важливо?
Масиви часто використовуються для зберігання різнорідних даних, наприклад, імені, прізвища та віку особи. Проблема в тому, що кожне значення в масиві ідентифікується лише за індексом. Це ускладнює читання та підтримку коду, оскільки стає незрозуміло, який елемент за що відповідає. Навіть невелика зміна у структурі масиву, наприклад, додавання нового значення, може порушити весь механізм доступу до даних.
Коли застосовувати?
* Якщо масив містить дані, які логічно представляють різні властивості одного об’єкта.
* Коли доступ до масиву через індекси ускладнює розуміння коду.
* Якщо структура даних потребує розширення, і використання масиву створює ризик помилок.


Які проблеми вирішує?
1. Читабельність коду: Дані, представлені через об'єкт, стають самодокументованими, оскільки кожна властивість має своє ім'я.
2. Мінімізація помилок: Розробники більше не покладаються на індекси, які легко переплутати.
3. Легке масштабування: Додавання нових властивостей до об'єкта не порушує існуючої логіки коду.


Переваги методу
* Зрозумілість: Код стає інтуїтивно зрозумілим навіть для нових членів команди.
* Гнучкість: Зручно розширювати структуру даних і додавати нові властивості.
* Безпека: Менше шансів на помилки, спричинені зміщенням індексів у масиві.


Обмеження
* Метод недоречний для масивів, що містять однотипні дані, наприклад, список цін або показників.
* Якщо дані масиву логічно не пов’язані між собою, заміна на об'єкт може ускладнити код.


Приклад застосування
Код до рефакторингу
Припустимо, що у вас є система для управління замовленнями, де інформація про клієнта зберігається в масиві. Позиції масиву мають фіксоване значення, наприклад:
* Ім'я клієнта ([0]),
* Адреса ([1]),
* Телефонний номер ([2]).


string[] customerInfo = new string[3];
customerInfo[0] = "John Doe";
customerInfo[1] = "123 Elm Street";
customerInfo[2] = "555-1234";


// Використання масиву:
Console.WriteLine($"Клієнт: {customerInfo[0]}, Адреса: {customerInfo[1]}, Телефон: {customerInfo[2]}");


Проблеми:
1. Низька читабельність: незрозуміло, які саме дані відповідають певним індексам.
2. Складність у підтримці: додавання нових полів або змінення структури вимагає змін у багатьох місцях коду.
3. Вразливість до помилок: неправильне використання індексу може призвести до некоректного доступу до даних.


Код після рефакторингу
Замість масиву створюється об'єкт Customer, який чітко визначає, які поля існують і як до них отримати доступ.
public class Customer
{
    public string Name { get; set; }
    public string Address { get; set; }
    public string PhoneNumber { get; set; }


    public Customer(string name, string address, string phoneNumber)
    {
        Name = name;
        Address = address;
        PhoneNumber = phoneNumber;
    }
}


// Використання:
Customer customer = new Customer("John Doe", "123 Elm Street", "555-1234");
Console.WriteLine($"Клієнт: {customer.Name}, Адреса: {customer.Address}, Телефон: {customer.PhoneNumber}");


Зміни та їх покращення:
1. Чіткість структури: об'єкт Customer має іменовані властивості, які роблять код зрозумілішим.
2. Легкість у підтримці: додавання нових полів до об'єкта (наприклад, email) відбувається централізовано, без зміни багатьох місць коду.
3. Безпека та мінімізація помилок: звертання до властивостей через імена, а не індекси, зменшує ризик помилок.
4. Можливість розширення: можна додати методи до класу Customer для обробки його даних (наприклад, форматування адреси).
3. Hide Delegate (Приховування делегата)
Hide Delegate – це метод рефакторингу, що дозволяє приховати використання делегата (або іншого проміжного об'єкта) від клієнтського коду. Цей метод забезпечує зручніший і безпечніший доступ до делегованої поведінки, що значно підвищує інкапсуляцію і зменшує зв'язність між компонентами.


Чому це важливо?
У системах із глибокими структурами об’єктів клієнтський код часто викликає методи через послідовність викликів, наприклад:
objectA.getObjectB().getObjectC().someMethod();
Такий підхід створює сильну залежність клієнтського коду від структури об’єктів. Якщо змінюється структура, доводиться оновлювати всі місця, де використовується цей ланцюжок викликів. Hide Delegate вирішує цю проблему, вводячи проміжний метод, який приховує складність і захищає клієнтський код від змін у структурі.


Коли застосовувати?
* Якщо клієнтський код має довгі ланцюжки викликів, які створюють залежність від структури об’єктів.
* Коли потрібно змінити внутрішню структуру класів без впливу на зовнішній код.
* Якщо потрібно підвищити інкапсуляцію і приховати деталі реалізації делегованої поведінки.


Які проблеми вирішує?
1. Зменшення зв'язності: Клієнтський код перестає залежати від деталей внутрішньої структури об'єктів.
2. Гнучкість у змінах: Зміна структури або делегата не впливає на клієнтський код.
3. Читабельність: Код стає простішим і легшим для розуміння, оскільки приховується зайва складність.


Переваги методу
* Інкапсуляція: Деталі делегування приховані за чітко визначеним інтерфейсом.
* Стабільність API: Клієнтський код не залежить від змін у внутрішній структурі.
* Зменшення складності: Полегшується підтримка та розвиток системи.


Обмеження
* Перевантаження коду: Якщо сховати всі делегати, то може з'явитися забагато додаткових методів, які тільки передають виклики іншим методам. Це ускладнить код.
* Недоцільність у простих структурах: У невеликих проєктах або системах із простими структурами цей метод може додати зайвого рівня абстракції.
Приклад використання
Проблема
Уявімо, що ми розробляємо систему для керування замовленнями в інтернет-магазині. Клас OrderService має методи для обробки замовлень і викликає методи з класу CustomerService для управління клієнтами. Проте ми хочемо приховати деталі реалізації CustomerService для спрощення API та збільшення гнучкості системи.
Код до рефакторингу
using System;


// Клас для управління клієнтами
class CustomerService
{
    public void AddCustomer(string customerName)
    {
        Console.WriteLine($"Adding customer: {customerName}");
    }


    public void RemoveCustomer(string customerName)
    {
        Console.WriteLine($"Removing customer: {customerName}");
    }
}


// Клас для обробки замовлень
class OrderService
{
    private CustomerService _customerService;


    public OrderService(CustomerService customerService)
    {
        _customerService = customerService;
    }


    public void PlaceOrder(string customerName, string orderDetails)
    {
        // Пряме делегування до CustomerService
        _customerService.AddCustomer(customerName);
        Console.WriteLine($"Placing order: {orderDetails}");
    }


    public void CancelOrder(string customerName, string orderDetails)
    {
        // Пряме делегування до CustomerService
        _customerService.RemoveCustomer(customerName);
        Console.WriteLine($"Cancelling order: {orderDetails}");
    }
}


Опис проблеми
У цьому коді клас OrderService безпосередньо делегує виклики до методів класу CustomerService. Це створює сильну залежність між цими класами. У разі зміни логіки роботи з клієнтами потрібно буде змінювати й код в OrderService. Крім того, ми порушуємо принцип інкапсуляції, оскільки користувачі класу OrderService мають доступ до внутрішніх методів CustomerService.
Код після рефакторингу
using System;


// Клас для управління клієнтами
class CustomerService
{
    public void AddCustomer(string customerName)
    {
        Console.WriteLine($"Adding customer: {customerName}");
    }


    public void RemoveCustomer(string customerName)
    {
        Console.WriteLine($"Removing customer: {customerName}");
    }
}


// Клас-проксі для приховування делегування
class CustomerProxy
{
    private CustomerService _customerService;


    public CustomerProxy(CustomerService customerService)
    {
        _customerService = customerService;
    }


    public void AddCustomer(string customerName)
    {
        // Додаткові дії перед делегуванням, наприклад, логування чи перевірки
        Console.WriteLine("Proxy: Adding customer via proxy.");
        _customerService.AddCustomer(customerName);
    }


    public void RemoveCustomer(string customerName)
    {
        // Додаткові дії перед делегуванням
        Console.WriteLine("Proxy: Removing customer via proxy.");
        _customerService.RemoveCustomer(customerName);
    }
}


// Клас для обробки замовлень
class OrderService
{
    private CustomerProxy _customerProxy;


    public OrderService(CustomerProxy customerProxy)
    {
        _customerProxy = customerProxy;
    }


    public void PlaceOrder(string customerName, string orderDetails)
    {
        // Використовуємо проксі замість прямого доступу до CustomerService
        _customerProxy.AddCustomer(customerName);
        Console.WriteLine($"Placing order: {orderDetails}");
    }


    public void CancelOrder(string customerName, string orderDetails)
    {
        // Використовуємо проксі замість прямого доступу до CustomerService
        _customerProxy.RemoveCustomer(customerName);
        Console.WriteLine($"Cancelling order: {orderDetails}");
    }
}


Опис змін
1. Створено клас-проксі CustomerProxy: Тепер замість безпосереднього виклику методів CustomerService через OrderService ми використовуємо проксі. Проксі здійснює додаткову логіку перед тим, як делегувати виклик до CustomerService. Це дає змогу, наприклад, додавати логування, перевірки або інші додаткові операції, не змінюючи сам клас OrderService.
2. Зміни в OrderService: Тепер замість безпосереднього звернення до методів CustomerService, клас OrderService використовує проксі. Це приховує складні деталі управління клієнтами і дозволяє зберегти простоту API для користувача OrderService.
Покращення
1. Зменшення залежностей: Тепер клас OrderService не має прямого доступу до реалізації CustomerService. Вся взаємодія з клієнтами проходить через проксі. Це знижує залежність між класами.
2. Легкість для розширення: У майбутньому можна змінювати логіку обробки клієнтів, додаючи нові методи в проксі, не змінюючи код в OrderService.
3. Поліпшення інкапсуляції: Клас OrderService більше не має прямого доступу до методів CustomerService. Це дозволяє приховати внутрішні деталі реалізації і зберегти простоту та гнучкість API.
4. Можливість для додаткової логіки: Якщо потрібно, проксі можна доповнити додатковими перевірками, логуванням або іншою поведінкою, не торкаючись основного класу.


4. Encapsulate Collection.
Encapsulate Collection — це метод рефакторингу, який полягає в тому, щоб приховати колекцію, таку як список чи масив, усередині об’єкта та надавати доступ до даних через методи або властивості замість прямого доступу до колекції. Це допомагає контролювати маніпуляції з колекцією, знижує ризик несанкціонованих змін і забезпечує гнучкість для майбутніх змін у структурі даних.
Чому це важливо?
Прямий доступ до колекцій, таких як списки або масиви, може привести до проблем з їхньою маніпуляцією в різних частинах програми. Безконтрольний доступ може призвести до помилок, наприклад, коли елементи колекції змінюються, але це не помічається в інших частинах програми. Підхід з інкапсуляцією дозволяє зберігати контроль над тим, як колекція змінюється, і дозволяє уникнути небажаних побічних ефектів.
Коли застосовувати?
* Якщо колекція використовується у кількох частинах програми і потрібно мати контроль над її доступом та змінами.
* Якщо потрібно обмежити доступ до колекції та дозволити лише певні операції, наприклад, додавання або видалення елементів.
* Якщо структура колекції має змінюватись у майбутньому (наприклад, заміна списку на іншу колекцію).
Проблеми, які вирішує
* Контроль доступу: Замість того, щоб надавати прямий доступ до колекції, ми можемо обмежити можливості для зовнішніх частин програми (наприклад, можна заборонити видалення елементів колекції без перевірки).
* Безпека даних: Внесення змін у колекцію без належного контролю може призвести до помилок. Інкапсуляція дозволяє краще керувати тим, хто і як змінює колекцію.
* Гнучкість: Легко змінювати реалізацію колекції, не змінюючи весь код, який її використовує.
Переваги методу
* Безпека: Ми захищаємо колекцію від несанкціонованих змін.
* Гнучкість: Можна змінювати реалізацію колекції, не порушуючи логіку програми.
* Читабельність: Код стає більш зрозумілим і контрольованим, оскільки всі операції з колекцією виконуються через чітко визначені методи.
Обмеження
* Якщо колекція повинна бути доступною для швидкого та прямого доступу з багатьох частин програми, цей підхід може додати зайву складність.
* Для дуже простих сценаріїв, де колекція не має складних вимог, це може виглядати як надмірне ускладнення.
Приклад застосування
Код до рефакторингу
Припустимо, у нас є система для управління списком замовлень, де всі замовлення зберігаються в колекції List<Order>. Замість того, щоб обробляти замовлення через інкапсульовані методи, ми дозволяємо прямий доступ до списку замовлень.
using System;
using System.Collections.Generic;


// Клас замовлення
class Order
{
    public string OrderId { get; set; }
    public string CustomerName { get; set; }
}


// Клас для управління замовленнями
class OrderService
{
    public List<Order> Orders { get; set; } = new List<Order>();


    public void AddOrder(Order order)
    {
        Orders.Add(order);
    }


    public void RemoveOrder(string orderId)
    {
        Orders.RemoveAll(o => o.OrderId == orderId);
    }


    public void PrintOrders()
    {
        foreach (var order in Orders)
        {
            Console.WriteLine($"Order ID: {order.OrderId}, Customer: {order.CustomerName}");
        }
    }
}


Проблеми:
1. Прямий доступ до колекції: Хтось може випадково змінити колекцію зовні або зробити несанкціоновані маніпуляції з нею.
2. Відсутність контролю: Ми не перевіряємо, чи правильний порядок додавання/видалення замовлень, не валідуємо дані перед додаванням.
3. Легко зробити помилку: Наприклад, хтось може випадково додати дублікати або видалити замовлення без перевірки його наявності.
Код після рефакторингу
Замінимо прямий доступ до колекції на інкапсульовані методи, щоб мати більше контролю за даними.
using System;
using System.Collections.Generic;


// Клас замовлення
class Order
{
    public string OrderId { get; set; }
    public string CustomerName { get; set; }
}


// Клас для управління замовленнями
class OrderService
{
    private List<Order> Orders { get; set; } = new List<Order>();


    // Метод для додавання замовлення
    public void AddOrder(Order order)
    {
        // Перевірка перед додаванням
        if (string.IsNullOrEmpty(order.OrderId))
        {
            Console.WriteLine("Order ID is required.");
            return;
        }
        Orders.Add(order);
        Console.WriteLine($"Order {order.OrderId} added.");
    }


    // Метод для видалення замовлення
    public void RemoveOrder(string orderId)
    {
        var order = Orders.Find(o => o.OrderId == orderId);
        if (order != null)
        {
            Orders.Remove(order);
            Console.WriteLine($"Order {orderId} removed.");
        }
        else
        {
            Console.WriteLine($"Order {orderId} not found.");
        }
    }


    // Метод для виведення замовлень
    public void PrintOrders()
    {
        foreach (var order in Orders)
        {
            Console.WriteLine($"Order ID: {order.OrderId}, Customer: {order.CustomerName}");
        }
    }
}


Зміни та їх покращення:
1. Інкапсуляція колекції: Тепер колекція Orders є приватною, і доступ до неї здійснюється лише через чітко визначені методи (AddOrder, RemoveOrder).
2. Перевірки перед маніпуляціями з колекцією: Додано перевірки для валідації даних перед додаванням або видаленням замовлення. Це дозволяє уникнути помилок, наприклад, додавання замовлення без ідентифікатора.
3. Безпека та контроль: Всі зміни в колекції контролюються через методи, що дає змогу уникнути несанкціонованих змін і забезпечити правильний порядок дій.
4. Гнучкість і масштабованість: Тепер, якщо нам потрібно змінити структуру даних (наприклад, замінити List<Order> на іншу колекцію), нам не потрібно змінювати весь код, а лише реалізацію методів, що працюють із цією колекцією.


5. Інструменти рефакторингу


JetBrains IDE
JetBrains має кілька середовищ для різних мов програмування — IntelliJ IDEA для Java, Rider для .NET, PhpStorm для PHP тощо. Ці інструменти чудово підтримують рефакторинг. Наприклад, у IntelliJ IDEA легко можна перейменувати змінні, методи та класи, а всі виклики цих елементів автоматично оновляться. Також є інструменти для перевірки коду, які допомагають знаходити потенційні проблеми ще на етапі написання. Навігація по проекту — суперзручна, можна швидко знайти клас чи метод. Єдиний мінус — ці IDE дорогі, особливо для малих проектів чи фрілансерів, і можуть бути важкими для простих задач.
Visual Studio
Visual Studio — класичне середовище для .NET. Має потужні інструменти для рефакторингу, такі як перейменування елементів, створення властивостей із полів та реорганізація коду. CodeLens допомагає бачити, хто і коли змінював код, що дуже корисно для командної роботи. Ще одне плюшка — інтеграція з іншими інструментами, наприклад, для тестування чи аналізу коду, що дозволяє швидко перевірити, чи не зламалася функціональність після рефакторингу. Проте, Visual Studio може здатися важким для новачків і маленьких проектів через велику кількість функцій.
Eclipse
Eclipse — це середовище, яке зазвичай асоціюється з Java, але підтримує й інші мови завдяки плагінам. Інструменти для рефакторингу тут схожі на ті, що в JetBrains IDE — перейменування змінних, реорганізація коду, виправлення структурних проблем. Також є інтеграція з інструментами для статичного аналізу коду. Eclipse — хороший вибір для тих, хто працює з Java, але може бути не таким зручним для інших мов.
SonarQube
SonarQube — це потужний інструмент для аналізу якості коду, який також допомагає з рефакторингом. Він виявляє проблеми в коді, наприклад, складність або дублювання, і дає поради, як їх виправити. SonarQube інтегрується з CI/CD інструментами, що дозволяє автоматизувати перевірку якості під час розробки. Він чудово підходить для великих проєктів та команд, але може бути складним для новачків і дорогим у повній версії.


6. Висновки
Рефакторинг є важливою частиною процесу розробки, що дозволяє покращити якість коду без зміни його зовнішньої поведінки. Розглянуті методи, такі як Replace Array with Object, Hide Delegate та Encapsulate Collection, надають ефективні способи оптимізації коду, підвищення його читабельності та безпеки. Вибір правильного методу залежить від типу проєкту та потреб команди, але кожен з них має свої переваги в контексті рефакторингу різних аспектів програмного забезпечення.
Однак, щоб реалізувати ці методи ефективно, важливо мати відповідні інструменти. Такі середовища розробки, як JetBrains IDE, Visual Studio, Eclipse, а також інструменти для аналізу якості коду, наприклад, SonarQube, значно полегшують цей процес. Вони пропонують автоматизовані функції для безпечного рефакторингу, інструменти для статичного аналізу та інтеграцію з іншими засобами, що допомагає покращити якість коду на всіх етапах розробки.
Отже, комбінуючи ефективні методи рефакторингу з потужними інструментами, можна значно покращити підтримуваність, безпеку і масштабованість програмного коду, що в свою чергу підвищує ефективність і знижує кількість помилок у проєкті.
